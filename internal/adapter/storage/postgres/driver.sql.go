// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: driver.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createDriver = `-- name: CreateDriver :one
INSERT INTO drivers (fleet_id, name, phone, status, current_location)
VALUES ($1, $2, $3, $4, ST_SetSRID(ST_MakePoint($5, $6), 4326))
RETURNING id, created_at
`

type CreateDriverParams struct {
	FleetID       uuid.UUID
	Name          string
	Phone         string
	Status        DriverStatus
	StMakepoint   interface{}
	StMakepoint_2 interface{}
}

type CreateDriverRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) CreateDriver(ctx context.Context, arg CreateDriverParams) (CreateDriverRow, error) {
	row := q.db.QueryRow(ctx, createDriver,
		arg.FleetID,
		arg.Name,
		arg.Phone,
		arg.Status,
		arg.StMakepoint,
		arg.StMakepoint_2,
	)
	var i CreateDriverRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const findNearestDrivers = `-- name: FindNearestDrivers :many
SELECT id, name, status,
       ST_Distance(current_location, ST_SetSRID(ST_MakePoint($2, $3), 4326)) as dist_meters
FROM drivers
WHERE fleet_id = $1 
  AND status = 'idle'
ORDER BY current_location <-> ST_SetSRID(ST_MakePoint($2, $3), 4326)
LIMIT 10
`

type FindNearestDriversParams struct {
	FleetID       uuid.UUID
	StMakepoint   interface{}
	StMakepoint_2 interface{}
}

type FindNearestDriversRow struct {
	ID         uuid.UUID
	Name       string
	Status     DriverStatus
	DistMeters interface{}
}

func (q *Queries) FindNearestDrivers(ctx context.Context, arg FindNearestDriversParams) ([]FindNearestDriversRow, error) {
	rows, err := q.db.Query(ctx, findNearestDrivers, arg.FleetID, arg.StMakepoint, arg.StMakepoint_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindNearestDriversRow
	for rows.Next() {
		var i FindNearestDriversRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Status,
			&i.DistMeters,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDriver = `-- name: GetDriver :one
SELECT id, fleet_id, name, phone, status, ST_AsText(current_location) as location
FROM drivers
WHERE id = $1 LIMIT 1
`

type GetDriverRow struct {
	ID       uuid.UUID
	FleetID  uuid.UUID
	Name     string
	Phone    string
	Status   DriverStatus
	Location interface{}
}

func (q *Queries) GetDriver(ctx context.Context, id uuid.UUID) (GetDriverRow, error) {
	row := q.db.QueryRow(ctx, getDriver, id)
	var i GetDriverRow
	err := row.Scan(
		&i.ID,
		&i.FleetID,
		&i.Name,
		&i.Phone,
		&i.Status,
		&i.Location,
	)
	return i, err
}

const getDriverByEmail = `-- name: GetDriverByEmail :one
SELECT id, password_hash, name, status
FROM drivers
WHERE email = $1 LIMIT 1
`

type GetDriverByEmailRow struct {
	ID           uuid.UUID
	PasswordHash string
	Name         string
	Status       DriverStatus
}

func (q *Queries) GetDriverByEmail(ctx context.Context, email string) (GetDriverByEmailRow, error) {
	row := q.db.QueryRow(ctx, getDriverByEmail, email)
	var i GetDriverByEmailRow
	err := row.Scan(
		&i.ID,
		&i.PasswordHash,
		&i.Name,
		&i.Status,
	)
	return i, err
}

const listDriversByFleet = `-- name: ListDriversByFleet :many
SELECT id, name, phone, status
FROM drivers
WHERE fleet_id = $1
ORDER BY name
`

type ListDriversByFleetRow struct {
	ID     uuid.UUID
	Name   string
	Phone  string
	Status DriverStatus
}

func (q *Queries) ListDriversByFleet(ctx context.Context, fleetID uuid.UUID) ([]ListDriversByFleetRow, error) {
	rows, err := q.db.Query(ctx, listDriversByFleet, fleetID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListDriversByFleetRow
	for rows.Next() {
		var i ListDriversByFleetRow
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Phone,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
