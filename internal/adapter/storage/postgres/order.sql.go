// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: order.sql

package postgres

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const assignDriverToOrder = `-- name: AssignDriverToOrder :exec
UPDATE orders
SET driver_id = $1, status = 'assigned', updated_at = NOW()
WHERE id = $2
`

type AssignDriverToOrderParams struct {
	DriverID pgtype.UUID
	ID       uuid.UUID
}

func (q *Queries) AssignDriverToOrder(ctx context.Context, arg AssignDriverToOrderParams) error {
	_, err := q.db.Exec(ctx, assignDriverToOrder, arg.DriverID, arg.ID)
	return err
}

const confirmOrderAcceptance = `-- name: ConfirmOrderAcceptance :exec
UPDATE drivers
SET status = 'en_route', updated_at = NOW()
WHERE id = $1
`

func (q *Queries) ConfirmOrderAcceptance(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, confirmOrderAcceptance, id)
	return err
}

const createOrder = `-- name: CreateOrder :one
INSERT INTO orders (fleet_id, amount_cents, status, pickup_location, dropoff_location)
VALUES ($1, $2, 'pending', ST_SetSRID(ST_MakePoint($3, $4), 4326), ST_SetSRID(ST_MakePoint($5, $6), 4326))
RETURNING id, created_at
`

type CreateOrderParams struct {
	FleetID       uuid.UUID
	AmountCents   int32
	StMakepoint   interface{}
	StMakepoint_2 interface{}
	StMakepoint_3 interface{}
	StMakepoint_4 interface{}
}

type CreateOrderRow struct {
	ID        uuid.UUID
	CreatedAt time.Time
}

func (q *Queries) CreateOrder(ctx context.Context, arg CreateOrderParams) (CreateOrderRow, error) {
	row := q.db.QueryRow(ctx, createOrder,
		arg.FleetID,
		arg.AmountCents,
		arg.StMakepoint,
		arg.StMakepoint_2,
		arg.StMakepoint_3,
		arg.StMakepoint_4,
	)
	var i CreateOrderRow
	err := row.Scan(&i.ID, &i.CreatedAt)
	return i, err
}

const markOrderArrived = `-- name: MarkOrderArrived :execrows
UPDATE orders
SET status = 'arrived', updated_at = NOW()
WHERE id = $1 AND driver_id = $2 AND status = 'assigned'
`

type MarkOrderArrivedParams struct {
	ID       uuid.UUID
	DriverID pgtype.UUID
}

func (q *Queries) MarkOrderArrived(ctx context.Context, arg MarkOrderArrivedParams) (int64, error) {
	result, err := q.db.Exec(ctx, markOrderArrived, arg.ID, arg.DriverID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markOrderDelivered = `-- name: MarkOrderDelivered :execrows
UPDATE orders
SET status = 'delivered', updated_at = NOW()
WHERE id = $1 AND driver_id = $2 AND status = 'picked_up'
`

type MarkOrderDeliveredParams struct {
	ID       uuid.UUID
	DriverID pgtype.UUID
}

func (q *Queries) MarkOrderDelivered(ctx context.Context, arg MarkOrderDeliveredParams) (int64, error) {
	result, err := q.db.Exec(ctx, markOrderDelivered, arg.ID, arg.DriverID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const markOrderPickedUp = `-- name: MarkOrderPickedUp :execrows
UPDATE orders
SET status = 'picked_up', updated_at = NOW()
WHERE id = $1 AND driver_id = $2 AND status = 'arrived'
`

type MarkOrderPickedUpParams struct {
	ID       uuid.UUID
	DriverID pgtype.UUID
}

func (q *Queries) MarkOrderPickedUp(ctx context.Context, arg MarkOrderPickedUpParams) (int64, error) {
	result, err := q.db.Exec(ctx, markOrderPickedUp, arg.ID, arg.DriverID)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const rejectOrderAssignment = `-- name: RejectOrderAssignment :exec
UPDATE orders
SET driver_id = NULL,
    status = 'pending',
    updated_at = NOW()
WHERE id = $1 AND driver_id = $2 AND status = 'assigned'
`

type RejectOrderAssignmentParams struct {
	ID       uuid.UUID
	DriverID pgtype.UUID
}

func (q *Queries) RejectOrderAssignment(ctx context.Context, arg RejectOrderAssignmentParams) error {
	_, err := q.db.Exec(ctx, rejectOrderAssignment, arg.ID, arg.DriverID)
	return err
}

const setDriverStatus = `-- name: SetDriverStatus :exec
UPDATE drivers
SET status = $2, updated_at = NOW()
WHERE id = $1
`

type SetDriverStatusParams struct {
	ID     uuid.UUID
	Status DriverStatus
}

func (q *Queries) SetDriverStatus(ctx context.Context, arg SetDriverStatusParams) error {
	_, err := q.db.Exec(ctx, setDriverStatus, arg.ID, arg.Status)
	return err
}
